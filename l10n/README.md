Markdown

# Mobick Logbook Localization (l10n) Developer Notes

## High-level overview (Mobick Fork Workflow)
1. Python code indicates text that needs to be translated (using `_()`, `_mft()`, or `ButtonOption`).
1. Since we maintain a fork, we **do not** use Transifex.
1. Instead, we manually manage translation mappings in a local Python script (e.g., `make_korean.py`).
1. We run this script to generate/compile the `messages.mo` file.
1. The `messages.mo` file is placed in `src/seedsigner/resources/seedsigner-translations/l10n/{LOCALE}/LC_MESSAGES/`.
1. The SeedSigner app loads this binary file to display text in the selected language.


## "Wrapping" text for translation
Any text that we want to be presented in multiple languages needs to "wrapped".
*(Note: This logic remains the same as the original SeedSigner)*

The CORE CONCEPT to understand is that wrapping is used in TWO different contexts:
1. **Marking:** Identify text that needs translation.
2. **Displaying:** Return the locale-specific translation (defaults to English if missing).

#### Technique 1: `ButtonOption`
Used for button labels.
```python
class SomeView(View):
    # These string literals will be marked for translation
    OPTION_1 = ButtonOption("Option 1!")
ButtonOption marks the string for translation but always returns the English string at runtime.

The English string serves as the "Key" to look up the translation in the .mo file.

Technique 2: mark_for_translation (_mft)
Used for class-level attributes that are NOT buttons (e.g., titles, headers).

Python

from seedsigner.helpers.l10n import mark_for_translation as _mft
title: str = _mft("Default Title")
Like ButtonOption, this marks the string but keeps the value as English to use as a lookup key.

Technique 3: gettext (_())
Used for dynamic text inside functions.

Python

from gettext import gettext as _
self.some_var = _("I will be dynamically fetched")
This marks the string AND immediately attempts to fetch the translated value.

Adding/Updating Translations (Manual Method)
Since we are not using the automated babel + Transifex pipeline, we use a lightweight Python script to compile translations.

1. Identify New Strings
If you added new text to the code (e.g., "Scan Mobick QR"), you must add this English string and its Korean translation to your generator script.

2. Update make_korean.py
Open your local compilation script and add the new key-value pair.

Python

translations = {
    # Existing entries...
    "Settings": "설정",
    
    # NEW entries
    "Scan Mobick QR": "모빅 QR 스캔",
    "Mobick Logbook": "모빅 로그북",
}
3. Compile .mo File
Run the script to generate the binary message catalog.

Bash

python3 make_korean.py
Output: messages.mo

Location: src/seedsigner/resources/seedsigner-translations/l10n/ko/LC_MESSAGES/

4. Verify
Build the Docker image or restart the service to see the changes.

Directory Structure
Ensure the translation files are in the correct path for the application to find them:

Plaintext

seedsigner/
└── src/
    └── seedsigner/
        └── resources/
            └── seedsigner-translations/
                └── l10n/
                    ├── ko/                  <-- Korean Locale
                    │   └── LC_MESSAGES/
                    │       └── messages.mo  <-- Compiled binary (Generated by script)
                    └── en/                  <-- English (Default, usually empty)